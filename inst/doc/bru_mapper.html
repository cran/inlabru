<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />



<title>Devel: Customised model components with the bru_mapper system</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>

<style type="text/css">
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
</style>



<style type="text/css">
code {
white-space: pre;
}
.sourceCode {
overflow: visible;
}
</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
{ counter-reset: source-line 0; }
pre.numberSource code > span
{ position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
{ content: counter(source-line);
position: relative; left: -1em; text-align: right; vertical-align: baseline;
border: none; display: inline-block;
-webkit-touch-callout: none; -webkit-user-select: none;
-khtml-user-select: none; -moz-user-select: none;
-ms-user-select: none; user-select: none;
padding: 0 4px; width: 4em;
color: #aaaaaa;
}
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; padding-left: 4px; }
div.sourceCode
{ }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } 
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.at { color: #7d9029; } 
code span.bn { color: #40a070; } 
code span.bu { color: #008000; } 
code span.cf { color: #007020; font-weight: bold; } 
code span.ch { color: #4070a0; } 
code span.cn { color: #880000; } 
code span.co { color: #60a0b0; font-style: italic; } 
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.do { color: #ba2121; font-style: italic; } 
code span.dt { color: #902000; } 
code span.dv { color: #40a070; } 
code span.er { color: #ff0000; font-weight: bold; } 
code span.ex { } 
code span.fl { color: #40a070; } 
code span.fu { color: #06287e; } 
code span.im { color: #008000; font-weight: bold; } 
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.kw { color: #007020; font-weight: bold; } 
code span.op { color: #666666; } 
code span.ot { color: #007020; } 
code span.pp { color: #bc7a00; } 
code span.sc { color: #4070a0; } 
code span.ss { color: #bb6688; } 
code span.st { color: #4070a0; } 
code span.va { color: #19177c; } 
code span.vs { color: #4070a0; } 
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } 
</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    var j = 0;
    while (j < rules.length) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") {
        j++;
        continue;
      }
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') {
        j++;
        continue;
      }
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Devel: Customised model components with the
bru_mapper system</h1>



<p>(Vignette under construction!)</p>
<div id="mapper-system-introduction" class="section level2">
<h2>Mapper system introduction</h2>
<p>Each inlabru latent model component generates an <em>effect</em>,
given the latent <em>state</em> vector. The purpose of the mapper system
is to define the link from state vectors to effect vectors. For an
ordinary model component, named <span class="math inline">\(c\)</span>,
this link can be represented as a matrix-vector product <span class="math display">\[
\eta_c(u_c) = A_c(\text{input}) u_c,
\]</span> where <span class="math inline">\(u_c\)</span> is the latent
state vector, <span class="math inline">\(\eta_c(u_c)\)</span> is the
resulting component effect vector, and <span class="math inline">\(A_c(\text{input})\)</span> is a <em>component
model matrix</em>. This matrix depends on the component inputs
(covariates, index information, etc) from <code>main</code>,
<code>group</code>, <code>replicate</code>, and <code>weights</code> in
the component definition.</p>
<p>The wider scope of component definitions is discussed in the <a href="https://inlabru-org.github.io/inlabru/articles/component.html">component
vignette</a>. Here, we will focus on the mapper system itself, how the
basic building blocks are used to construct the built-in mappers, and
finally how to construct new mappers.</p>
<p>The in-package documentation for the mapper methods is contained in
four parts:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a>?bru_mapper <span class="co"># Mapper constructors, with links to predefined mappers</span></span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a>?bru_mapper_generics <span class="co"># Generic and default methods</span></span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a>?bru_get_mapper <span class="co"># Mapper extraction methods</span></span></code></pre></div>
<p>Regular users normally at most need some of the methods from
<code>?bru_mapper</code> and links to predefined mappers, and sometimes
<code>?bru_mapper_generics</code>. The <code>bru_mapper_define()</code>
and <code>bru_get_mapper()</code> methods are needed for those
implementing their own mapper class.</p>
</div>
<div id="mappers" class="section level2">
<h2>Mappers</h2>
<p>The main purpose of each mapper class is to allow evaluating a
component effect, from given <code>input</code> and latent
<code>state</code>, by calling</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a><span class="fu">ibm_eval</span>(mapper, input, state)</span></code></pre></div>
<p>for the <code>mapper</code> associated with the component
definition.</p>
<div id="basic-mappers" class="section level3">
<h3>Basic mappers</h3>
<p>Basic mappers take covariate vectors or matrices as input and numeric
vectors as state.</p>
<p>Constructors:</p>
<ul>
<li><code>bm_const()</code></li>
<li><code>bm_linear()</code></li>
<li><code>bm_index(n)</code></li>
<li><code>bm_factor(values, factor_mapping)</code></li>
<li><code>bm_matrix()</code></li>
<li><code>bm_harmonics(order, scaling, intercept, interval)</code></li>
</ul>
<div id="const" class="section level4">
<h4>const</h4>
<p>The <code>const</code> mapper defines a mapping from an empty state
vector. This is used to define offset components, <span class="math inline">\(\eta(u)_j = z_j\)</span>, where <span class="math inline">\(z\)</span> is a fixed input vector, indexed by
<span class="math inline">\(j\)</span>.</p>
</div>
<div id="linear" class="section level4">
<h4>linear</h4>
<p>The <code>linear</code> mapper defines a mapper from a length 1 state
vector. This is used to define ordinary “fixed” covariate effects,
linear in both the covariate and in the state variable; <span class="math inline">\(\eta(u)_j = z_j u\)</span>, where <span class="math inline">\(u\)</span> is the state, and <span class="math inline">\(z\)</span> is the input covariate vector.</p>
</div>
<div id="index" class="section level4">
<h4>index</h4>
<p>The <code>index(n)</code> mapper defines a direct mapping from a
length <code>n</code> state variable. This is used for structured and
unstructured “random effect” component effects; <span class="math inline">\(\eta(u)_j = u_{z_j}\)</span>, where <span class="math inline">\(u\)</span> is the state vector, and <span class="math inline">\(z\)</span> is the input index vector.</p>
</div>
<div id="factor" class="section level4">
<h4>factor</h4>
<p>The <code>factor(values, factor_mapping)</code> mapper defines a
direct mapping between a state vector of length equal to the number of
factor levels of <code>values</code> (for
<code>factor_mapping = &quot;full&quot;</code>), or one less (for
<code>factor_mapping = &quot;contrast&quot;</code>). Each factor level is
represented as a dummy 0/1 variable, or equivalently, the input is used
as a label index into the state vector; <span class="math inline">\(\eta(u)_j = u_{z_j}\)</span>. In the
<code>&quot;contrast&quot;</code> case, the first factor level is removed from the
model, and the corresponding effect defined to be zero.</p>
</div>
<div id="matrix" class="section level4">
<h4>matrix</h4>
<p>The <code>matrix</code> mapper defines a direct matrix multiplication
between a pre-computed model matrix <span class="math inline">\(A_\text{input}\)</span> with the state vector;
<span class="math inline">\(\eta(u) = A_\text{input} u\)</span>. This is
used e.g. for linear model formula input, that is converted to a
component model matrix before handing it over to the mapper system.</p>
</div>
<div id="harmonics" class="section level4">
<h4>harmonics</h4>
<p>The <code>harmonics(order, scaling, intercept, interval)</code>
mapper defines a sum of weighted harmonics on a real interval <span class="math inline">\((L, U)\)</span>, each frequency additionally
scaled by factors determined by <code>scale</code>; <span class="math inline">\(\eta(u_j) = \sum_{k=1}^{1+2p} A_{j,k}
u_k\)</span>, where <span class="math inline">\(A_{j,k}=s_k\)</span> for
<span class="math inline">\(k=1\)</span>, <span class="math inline">\(A_{j,2k}=s_{k+1}\cos[2\pi k (z_j -
L)/(U-L)]\)</span> for <span class="math inline">\(k=1,2,\dots,p\)</span>, and <span class="math inline">\(A_{j,2k+1}=s_{k+1}\sin[2\pi k (z_j -
L)/(U-L)]\)</span> for <span class="math inline">\(k=1,2,\dots,p\)</span>, where <span class="math inline">\(p=\)</span><code>order</code>. When
<code>intercept</code> is <code>TRUE</code>, the state vector has length
<span class="math inline">\(1+2p\)</span>. When <code>intercept</code>
is <code>FALSE</code>, the first, constant, column is removed, and the
state vector has length <span class="math inline">\(2p\)</span>.</p>
</div>
</div>
<div id="transformation-mappers" class="section level3">
<h3>Transformation mappers</h3>
<p>Transformation mappers are mappers that would normally be combined
with other mappers, as steps in a sequence of transformations, or as
individual transformation mappers.</p>
<ul>
<li><code>bm_scale()</code></li>
<li><code>bm_marginal(qfun, pfun, ...)</code></li>
<li><code>bm_aggregate(rescale)</code></li>
<li><code>bm_logsumexp(rescale)</code></li>
</ul>
<div id="scale" class="section level4">
<h4>scale</h4>
<p>The <code>scale</code> mapper multiplies the <code>input</code>
vector with the <code>state</code> vector. This is used for INLA models
to implement the <code>weights</code> component scaling, as the final
stage of a <code>pipe</code> mapper, see below.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a>mapper <span class="ot">&lt;-</span> <span class="fu">bm_scale</span>()</span>
<span id="cb3-2"><a href="#cb3-2" tabindex="-1"></a><span class="fu">ibm_eval</span>(mapper,</span>
<span id="cb3-3"><a href="#cb3-3" tabindex="-1"></a>  <span class="at">input =</span> ...,</span>
<span id="cb3-4"><a href="#cb3-4" tabindex="-1"></a>  <span class="at">state =</span> ...</span>
<span id="cb3-5"><a href="#cb3-5" tabindex="-1"></a>)</span></code></pre></div>
</div>
<div id="marginal" class="section level4">
<h4>marginal</h4>
<p>The <code>marginal</code> mapper transforms the <code>state</code>
vector from standardised Gaussian marginal distribution to the
distribution defined by a quantile function. This can be used to define
components with latent marginal <code>N(0,1)</code> distribution but
non-Gaussian effect.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a>mapper <span class="ot">&lt;-</span> <span class="fu">bm_marginal</span>(</span>
<span id="cb4-2"><a href="#cb4-2" tabindex="-1"></a>  <span class="at">qfun =</span> ..., <span class="at">pfun =</span> ..., <span class="at">dfun =</span> ..., ..., <span class="at">inverse =</span> ...</span>
<span id="cb4-3"><a href="#cb4-3" tabindex="-1"></a>)</span>
<span id="cb4-4"><a href="#cb4-4" tabindex="-1"></a><span class="fu">ibm_eval</span>(mapper,</span>
<span id="cb4-5"><a href="#cb4-5" tabindex="-1"></a>  <span class="at">input =</span> <span class="cn">NULL</span>, <span class="co"># If a list is given, it overrides the parameter specification</span></span>
<span id="cb4-6"><a href="#cb4-6" tabindex="-1"></a>  <span class="at">state =</span> ...</span>
<span id="cb4-7"><a href="#cb4-7" tabindex="-1"></a>)</span>
<span id="cb4-8"><a href="#cb4-8" tabindex="-1"></a></span>
<span id="cb4-9"><a href="#cb4-9" tabindex="-1"></a><span class="co"># Examples:</span></span>
<span id="cb4-10"><a href="#cb4-10" tabindex="-1"></a>mapper <span class="ot">&lt;-</span> <span class="fu">bm_marginal</span>(<span class="at">qfun =</span> qexp, <span class="at">rate =</span> <span class="dv">1</span> <span class="sc">/</span> <span class="dv">8</span>)</span>
<span id="cb4-11"><a href="#cb4-11" tabindex="-1"></a>mapper <span class="ot">&lt;-</span> <span class="fu">bm_marginal</span>(</span>
<span id="cb4-12"><a href="#cb4-12" tabindex="-1"></a>  <span class="at">qfun =</span> qexp, <span class="at">pfun =</span> pexp, <span class="at">dfun =</span> dexp, <span class="at">rate =</span> <span class="dv">1</span> <span class="sc">/</span> <span class="dv">8</span></span>
<span id="cb4-13"><a href="#cb4-13" tabindex="-1"></a>)</span></code></pre></div>
</div>
<div id="aggregate" class="section level4">
<h4>aggregate</h4>
<p>The <code>aggregate</code> mapper aggregates the <code>state</code>
vector elements by blockwise summation after scaling the elements by
weights. This can be used for summation, integration, and averaging (for
<code>rescale=TRUE</code>).</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a>mapper <span class="ot">&lt;-</span> <span class="fu">bm_aggregate</span>(<span class="at">rescale =</span> ...)</span>
<span id="cb5-2"><a href="#cb5-2" tabindex="-1"></a><span class="fu">ibm_eval</span>(mapper,</span>
<span id="cb5-3"><a href="#cb5-3" tabindex="-1"></a>  <span class="at">input =</span> <span class="fu">list</span>(<span class="at">block =</span> ..., <span class="at">weights =</span> ...),</span>
<span id="cb5-4"><a href="#cb5-4" tabindex="-1"></a>  <span class="at">state =</span> ...</span>
<span id="cb5-5"><a href="#cb5-5" tabindex="-1"></a>)</span></code></pre></div>
</div>
<div id="logsumexp" class="section level4">
<h4>logsumexp</h4>
<p>The <code>logsumexp</code> mapper aggregates the
<code>exp(state)</code> vector elements by blockwise summation after
scaling the elements by weights, and takes the logarithm. The
implementation takes care to avoid numerical overflow. This can be used
for summation, integration, and averaging (for
<code>rescale=TRUE</code>).</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a>mapper <span class="ot">&lt;-</span> <span class="fu">bm_logsumexp</span>(<span class="at">rescale =</span> ...)</span>
<span id="cb6-2"><a href="#cb6-2" tabindex="-1"></a><span class="fu">ibm_eval</span>(mapper,</span>
<span id="cb6-3"><a href="#cb6-3" tabindex="-1"></a>  <span class="at">input =</span> <span class="fu">list</span>(<span class="at">block =</span> ..., <span class="at">weights =</span> ...),</span>
<span id="cb6-4"><a href="#cb6-4" tabindex="-1"></a>  <span class="at">state =</span> ...</span>
<span id="cb6-5"><a href="#cb6-5" tabindex="-1"></a>)</span></code></pre></div>
</div>
</div>
<div id="compound-mappers" class="section level3">
<h3>Compound mappers</h3>
<p>Compound mappers define collections or chains of mappings, and can
take various forms of input. The state vector is normally a numeric
vector, but can in some cases be a list of vectors.</p>
<ul>
<li><code>bm_collect(mappers, hidden)</code></li>
<li><code>bm_multi(mappers)</code></li>
<li><code>bm_pipe(mappers)</code></li>
<li><code>bm_sum(mappers, single_input)</code></li>
<li><code>bm_repeat(mapper, n_rep, interleaved)</code></li>
</ul>
<div id="collect" class="section level4">
<h4>collect</h4>
<p>The <code>collect</code> mapper defines a compound mapper where the
Jacobian is block-diagonal, and each block is defined by a separate
sub-mapper. When <code>hidden = TRUE</code>, it can be used for INLA
models where the user-visible part of the latent state is only a part of
the internal state, such as for <code>&quot;bym&quot;</code> models.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a>mapper <span class="ot">&lt;-</span> <span class="fu">bm_collect</span>(<span class="fu">list</span>(<span class="at">name1 =</span> ..., <span class="at">name2 =</span> ..., ...),</span>
<span id="cb7-2"><a href="#cb7-2" tabindex="-1"></a>  <span class="at">hidden =</span> <span class="cn">FALSE</span></span>
<span id="cb7-3"><a href="#cb7-3" tabindex="-1"></a>)</span>
<span id="cb7-4"><a href="#cb7-4" tabindex="-1"></a><span class="fu">ibm_eval</span>(mapper,</span>
<span id="cb7-5"><a href="#cb7-5" tabindex="-1"></a>  <span class="at">input =</span> <span class="fu">list</span>(<span class="at">name1 =</span> ..., <span class="at">name2 =</span> ..., ...),</span>
<span id="cb7-6"><a href="#cb7-6" tabindex="-1"></a>  <span class="at">state =</span> ...</span>
<span id="cb7-7"><a href="#cb7-7" tabindex="-1"></a>)</span>
<span id="cb7-8"><a href="#cb7-8" tabindex="-1"></a><span class="co"># If hidden = TRUE, the inla_f=TRUE argument &quot;hides&quot; all but the first mapper:</span></span>
<span id="cb7-9"><a href="#cb7-9" tabindex="-1"></a><span class="fu">ibm_eval</span>(mapper,</span>
<span id="cb7-10"><a href="#cb7-10" tabindex="-1"></a>  <span class="at">input =</span> name1_input,</span>
<span id="cb7-11"><a href="#cb7-11" tabindex="-1"></a>  <span class="at">state =</span> ...,</span>
<span id="cb7-12"><a href="#cb7-12" tabindex="-1"></a>  <span class="at">inla_f =</span> <span class="cn">TRUE</span></span>
<span id="cb7-13"><a href="#cb7-13" tabindex="-1"></a>)</span></code></pre></div>
</div>
<div id="multi" class="section level4">
<h4>multi</h4>
<p>The <code>multi</code> mapper defines a compound mapper where the
Jacobian is the row-wise Kronecker product between the sub-mapper
Jacobians. This can be used for INLA models to construct the internal
mapper for <code>main</code>, <code>group</code>, and
<code>replicate</code>, but also for user-defined models where a single
<code>rgeneric</code> or <code>cgeneric</code> model is defined on e.g.
a space-time product domain.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a>mapper <span class="ot">&lt;-</span> <span class="fu">bm_multi</span>(<span class="fu">list</span>(<span class="at">name1 =</span> ..., <span class="at">name2 =</span> ..., ...))</span>
<span id="cb8-2"><a href="#cb8-2" tabindex="-1"></a><span class="fu">ibm_eval</span>(mapper,</span>
<span id="cb8-3"><a href="#cb8-3" tabindex="-1"></a>  <span class="at">input =</span> <span class="fu">list</span>(<span class="at">name1 =</span> ..., <span class="at">name2 =</span> ..., ...),</span>
<span id="cb8-4"><a href="#cb8-4" tabindex="-1"></a>  <span class="at">state =</span> ...</span>
<span id="cb8-5"><a href="#cb8-5" tabindex="-1"></a>)</span></code></pre></div>
</div>
<div id="pipe" class="section level4">
<h4>pipe</h4>
<p>Pipe mappers chain multiple mappers into a sequence, where the
evaluation result of each mapper is given as the state vector for the
next mapper.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a>mapper <span class="ot">&lt;-</span> <span class="fu">bm_pipe</span>(<span class="fu">list</span>(<span class="at">name1 =</span> ..., <span class="at">name2 =</span> ..., ...))</span>
<span id="cb9-2"><a href="#cb9-2" tabindex="-1"></a><span class="fu">ibm_eval</span>(mapper,</span>
<span id="cb9-3"><a href="#cb9-3" tabindex="-1"></a>  <span class="at">input =</span> <span class="fu">list</span>(<span class="at">name1 =</span> ..., <span class="at">name2 =</span> ..., ...),</span>
<span id="cb9-4"><a href="#cb9-4" tabindex="-1"></a>  <span class="at">state =</span> ...</span>
<span id="cb9-5"><a href="#cb9-5" tabindex="-1"></a>)</span></code></pre></div>
</div>
<div id="sum-from-version-2.12.0.9001" class="section level4">
<h4>sum (from version <code>2.12.0.9001</code>)</h4>
<p>Sum mappers take a list of mappers and adds their effects, based on a
state vector with the individual mapper states combined in sequence. The
<code>ibm_</code> method inputs are passed on to the sub-mapper methods.
When <code>single_input</code> is <code>TRUE</code>, the same input is
passed to all sub-mappers. Otherwise, the <code>input</code> must be a
<code>list</code>, <code>data.frame</code>, or <code>matrix</code>,
whose elements/columns are passed on to the respective sub-mappers.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" tabindex="-1"></a>mapper <span class="ot">&lt;-</span> <span class="fu">bm_sum</span>(<span class="at">mappers =</span> ..., <span class="at">single_input =</span> ...)</span>
<span id="cb10-2"><a href="#cb10-2" tabindex="-1"></a><span class="fu">ibm_eval</span>(mapper,</span>
<span id="cb10-3"><a href="#cb10-3" tabindex="-1"></a>  <span class="at">input =</span> ...,</span>
<span id="cb10-4"><a href="#cb10-4" tabindex="-1"></a>  <span class="at">state =</span> ...</span>
<span id="cb10-5"><a href="#cb10-5" tabindex="-1"></a>)</span></code></pre></div>
</div>
<div id="repeat" class="section level4">
<h4>repeat</h4>
<p>Repeat mappers take a single mapper and repeats it, corresponding to
a state vector of length <code>sum(n_rep) * ibm_n(mapper, ...)</code>.
The <code>ibm_</code> method inputs are passed on to the sub-mapper
methods.</p>
<p>If <code>interleaved</code> is <code>TRUE</code> (from version
<code>2.12.0.9001</code>), the repeated mappers are interleaved, e.g. if
the state vectors for two individual mappers were <code>x1</code> and
<code>x2</code>, interleaved mappers have state vector
<code>c(x1[1], x2[1], ..., x1[2], x2[2], ...)</code>, whereas ordinary
non-interleaved mappers have state vector
<code>c(x1, x2, ...)</code>.</p>
<p>For version <code>2.12.0.9001</code>, <code>n_rep</code> and
<code>interleaved</code> may be vectors, for grouped repetition and
interleaving. Non-interleaved repeats are combined, so that the
resulting internal mapper structure is a compact as possible.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a>mapper <span class="ot">&lt;-</span> <span class="fu">bm_repeat</span>(<span class="at">mapper =</span> ..., <span class="at">n_rep =</span> ..., <span class="at">interleaved =</span> ...)</span>
<span id="cb11-2"><a href="#cb11-2" tabindex="-1"></a><span class="fu">ibm_eval</span>(mapper,</span>
<span id="cb11-3"><a href="#cb11-3" tabindex="-1"></a>  <span class="at">input =</span> ...,</span>
<span id="cb11-4"><a href="#cb11-4" tabindex="-1"></a>  <span class="at">state =</span> ...</span>
<span id="cb11-5"><a href="#cb11-5" tabindex="-1"></a>)</span></code></pre></div>
</div>
<div id="the-core-model-component-mapper" class="section level4">
<h4>The core model component mapper</h4>
<p>All model component mappers are currently defined as a
<code>pipe</code> mapper containing a <code>multi</code> mapper followed
by a <code>scale</code> mapper:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" tabindex="-1"></a>mapper <span class="ot">&lt;-</span></span>
<span id="cb12-2"><a href="#cb12-2" tabindex="-1"></a>  <span class="fu">bm_pipe</span>(</span>
<span id="cb12-3"><a href="#cb12-3" tabindex="-1"></a>    <span class="fu">list</span>(</span>
<span id="cb12-4"><a href="#cb12-4" tabindex="-1"></a>      <span class="at">mapper =</span> <span class="fu">bm_multi</span>(<span class="fu">list</span>(<span class="at">main =</span> ..., <span class="at">group =</span> ..., <span class="at">replicate =</span> ...)),</span>
<span id="cb12-5"><a href="#cb12-5" tabindex="-1"></a>      <span class="at">scale =</span> <span class="fu">bm_scale</span>()</span>
<span id="cb12-6"><a href="#cb12-6" tabindex="-1"></a>    )</span>
<span id="cb12-7"><a href="#cb12-7" tabindex="-1"></a>  )</span>
<span id="cb12-8"><a href="#cb12-8" tabindex="-1"></a><span class="fu">ibm_eval</span>(mapper,</span>
<span id="cb12-9"><a href="#cb12-9" tabindex="-1"></a>  <span class="at">input =</span> <span class="fu">list</span>(</span>
<span id="cb12-10"><a href="#cb12-10" tabindex="-1"></a>    <span class="at">mapper =</span> <span class="fu">list</span>(<span class="at">main =</span> ..., <span class="at">group =</span> ..., <span class="at">replicate =</span> ...),</span>
<span id="cb12-11"><a href="#cb12-11" tabindex="-1"></a>    <span class="at">scale =</span> ...</span>
<span id="cb12-12"><a href="#cb12-12" tabindex="-1"></a>  ),</span>
<span id="cb12-13"><a href="#cb12-13" tabindex="-1"></a>  <span class="at">state =</span> ...</span>
<span id="cb12-14"><a href="#cb12-14" tabindex="-1"></a>)</span></code></pre></div>
</div>
</div>
<div id="object-mappers" class="section level3">
<h3>Object mappers</h3>
<p>For object with predefined mapper conversion methods, use
<code>bru_mapper(object)</code> to obtain a suitable mapper object.
Current predefined object mappers are defined for objects of these
classes:</p>
<ul>
<li><code>fm_mesh_2d</code> and <code>inla.mesh</code>; Use
<code>bru_mapper(object)</code> or <code>bm_fmesher(object)</code></li>
<li><code>fm_mesh_1d</code> and <code>inla.mesh.1d</code>; Use
<code>bru_mapper(object, indexed)</code> or, if
<code>indexed=TRUE</code>, <code>bm_fmesher(object)</code>.</li>
<li>Any object supporting the <code>fmesher::fm_dof()</code> and
<code>fmesher::fm_basis()</code> methods; Use
<code>bm_fmesher(object)</code>. If <code>fmesher</code> in the future
gains a common base class for such objects, a corresponding
<code>bru_mapper()</code> conversion method will be added.</li>
</ul>
<p>More details are given below.</p>
</div>
<div id="model-object-mappers" class="section level3">
<h3>Model object mappers</h3>
<p>For inla model objects with predefined mappers, use
<code>bru_get_mapper(object)</code> Current predefined model object
mappers are defined for models of these classes:</p>
<ul>
<li><code>inla.spde</code>; this includes
<code>inla.spde2.matern()</code> and <code>inla.spde2.pcmatern()</code>
models. The conversion method calls <code>bru_mapper()</code> in the
appropriate way for the mesh type used for the model</li>
<li><code>inla.rgeneric</code>; This relies on the rgeneric definition
including a <code>&quot;mapper&quot;</code> callback argument. A less invasive
method, that works for both rgeneric and cgeneric models, is to define a
<code>bru_get_mapper()</code> method for the class, which needs to
include a unique class identifier, e.g. add
<code>class(object) &lt;- c(&quot;my_unique_model_class&quot;, class(object))</code>
and define</li>
</ul>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" tabindex="-1"></a>bru_get_mapper.my_unique_model_class <span class="ot">&lt;-</span> <span class="cf">function</span>(model, ...) {</span>
<span id="cb13-2"><a href="#cb13-2" tabindex="-1"></a>  ...</span>
<span id="cb13-3"><a href="#cb13-3" tabindex="-1"></a>}</span></code></pre></div>
<p>and register it in the namespace.</p>
</div>
<div id="special-mappers" class="section level3">
<h3>Special mappers</h3>
<ul>
<li><code>bm_taylor()</code></li>
</ul>
</div>
</div>
<div id="mapper-methods" class="section level2">
<h2>Mapper methods</h2>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" tabindex="-1"></a><span class="fu">ibm_n</span>(mapper, inla_f, ...)</span>
<span id="cb14-2"><a href="#cb14-2" tabindex="-1"></a><span class="fu">ibm_n_output</span>(mapper, input, ...)</span>
<span id="cb14-3"><a href="#cb14-3" tabindex="-1"></a><span class="fu">ibm_values</span>(mapper, inla_f, ...)</span>
<span id="cb14-4"><a href="#cb14-4" tabindex="-1"></a><span class="fu">ibm_jacobian</span>(mapper, input, state, ...)</span>
<span id="cb14-5"><a href="#cb14-5" tabindex="-1"></a><span class="fu">ibm_eval</span>(mapper, input, state, ...)</span>
<span id="cb14-6"><a href="#cb14-6" tabindex="-1"></a><span class="fu">ibm_names</span>(mapper, ...)</span>
<span id="cb14-7"><a href="#cb14-7" tabindex="-1"></a><span class="fu">ibm_inla_subset</span>(mapper, ...)</span></code></pre></div>
<p>An example where the <code>inla_f</code> argument matters is the
<code>bm_collect</code> class, when the <code>hidden=TRUE</code>
argument is used to indicate that only the first mapper should be used
for the <code>INLA::f()</code> inputs, e.g. for <code>&quot;bym2&quot;</code>
models. For <code>inla_f=FALSE</code> (the default), the
<code>ibm_n</code> and <code>ibm_values</code> methods return the total
number of latent variables, but with <code>inla_f=TRUE</code> we get the
values needed by <code>INLA::f()</code> instead:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" tabindex="-1"></a>mapper <span class="ot">&lt;-</span> <span class="fu">bm_collect</span>(</span>
<span id="cb15-2"><a href="#cb15-2" tabindex="-1"></a>  <span class="fu">list</span>(</span>
<span id="cb15-3"><a href="#cb15-3" tabindex="-1"></a>    <span class="at">a =</span> <span class="fu">bm_index</span>(<span class="dv">3</span>),</span>
<span id="cb15-4"><a href="#cb15-4" tabindex="-1"></a>    <span class="at">b =</span> <span class="fu">bm_index</span>(<span class="dv">2</span>)</span>
<span id="cb15-5"><a href="#cb15-5" tabindex="-1"></a>  ),</span>
<span id="cb15-6"><a href="#cb15-6" tabindex="-1"></a>  <span class="at">hidden =</span> <span class="cn">TRUE</span></span>
<span id="cb15-7"><a href="#cb15-7" tabindex="-1"></a>)</span>
<span id="cb15-8"><a href="#cb15-8" tabindex="-1"></a><span class="fu">ibm_n</span>(mapper)</span>
<span id="cb15-9"><a href="#cb15-9" tabindex="-1"></a><span class="co">#&gt; [1] 5</span></span>
<span id="cb15-10"><a href="#cb15-10" tabindex="-1"></a><span class="fu">ibm_values</span>(mapper)</span>
<span id="cb15-11"><a href="#cb15-11" tabindex="-1"></a><span class="co">#&gt; [1] 1 2 3 4 5</span></span>
<span id="cb15-12"><a href="#cb15-12" tabindex="-1"></a><span class="fu">ibm_n</span>(mapper, <span class="at">inla_f =</span> <span class="cn">TRUE</span>)</span>
<span id="cb15-13"><a href="#cb15-13" tabindex="-1"></a><span class="co">#&gt; [1] 3</span></span>
<span id="cb15-14"><a href="#cb15-14" tabindex="-1"></a><span class="fu">ibm_values</span>(mapper, <span class="at">inla_f =</span> <span class="cn">TRUE</span>)</span>
<span id="cb15-15"><a href="#cb15-15" tabindex="-1"></a><span class="co">#&gt; [1] 1 2 3</span></span></code></pre></div>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" tabindex="-1"></a><span class="fu">ibm_n</span>(mapper, <span class="at">multi =</span> <span class="cn">TRUE</span>)</span>
<span id="cb16-2"><a href="#cb16-2" tabindex="-1"></a><span class="co">#&gt; $a</span></span>
<span id="cb16-3"><a href="#cb16-3" tabindex="-1"></a><span class="co">#&gt; [1] 3</span></span>
<span id="cb16-4"><a href="#cb16-4" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb16-5"><a href="#cb16-5" tabindex="-1"></a><span class="co">#&gt; $b</span></span>
<span id="cb16-6"><a href="#cb16-6" tabindex="-1"></a><span class="co">#&gt; [1] 2</span></span>
<span id="cb16-7"><a href="#cb16-7" tabindex="-1"></a><span class="fu">ibm_values</span>(mapper, <span class="at">multi =</span> <span class="cn">TRUE</span>)</span>
<span id="cb16-8"><a href="#cb16-8" tabindex="-1"></a><span class="co">#&gt; $a</span></span>
<span id="cb16-9"><a href="#cb16-9" tabindex="-1"></a><span class="co">#&gt; [1] 1 2 3</span></span>
<span id="cb16-10"><a href="#cb16-10" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb16-11"><a href="#cb16-11" tabindex="-1"></a><span class="co">#&gt; $b</span></span>
<span id="cb16-12"><a href="#cb16-12" tabindex="-1"></a><span class="co">#&gt; [1] 1 2</span></span>
<span id="cb16-13"><a href="#cb16-13" tabindex="-1"></a><span class="fu">ibm_n</span>(mapper, <span class="at">inla_f =</span> <span class="cn">TRUE</span>, <span class="at">multi =</span> <span class="cn">TRUE</span>)</span>
<span id="cb16-14"><a href="#cb16-14" tabindex="-1"></a><span class="co">#&gt; $a</span></span>
<span id="cb16-15"><a href="#cb16-15" tabindex="-1"></a><span class="co">#&gt; [1] 3</span></span>
<span id="cb16-16"><a href="#cb16-16" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb16-17"><a href="#cb16-17" tabindex="-1"></a><span class="co">#&gt; $b</span></span>
<span id="cb16-18"><a href="#cb16-18" tabindex="-1"></a><span class="co">#&gt; [1] 2</span></span>
<span id="cb16-19"><a href="#cb16-19" tabindex="-1"></a><span class="fu">ibm_values</span>(mapper, <span class="at">inla_f =</span> <span class="cn">TRUE</span>, <span class="at">multi =</span> <span class="cn">TRUE</span>)</span>
<span id="cb16-20"><a href="#cb16-20" tabindex="-1"></a><span class="co">#&gt; $a</span></span>
<span id="cb16-21"><a href="#cb16-21" tabindex="-1"></a><span class="co">#&gt; [1] 1 2 3</span></span>
<span id="cb16-22"><a href="#cb16-22" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb16-23"><a href="#cb16-23" tabindex="-1"></a><span class="co">#&gt; $b</span></span>
<span id="cb16-24"><a href="#cb16-24" tabindex="-1"></a><span class="co">#&gt; [1] 1 2</span></span></code></pre></div>
<p>For the <code>bm_multi</code> class, the <code>multi</code> argument
provides access to the inner layers of the multi-mapper:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" tabindex="-1"></a>mapper <span class="ot">&lt;-</span> <span class="fu">bm_multi</span>(<span class="fu">list</span>(</span>
<span id="cb17-2"><a href="#cb17-2" tabindex="-1"></a>  <span class="at">a =</span> <span class="fu">bm_index</span>(<span class="dv">3</span>),</span>
<span id="cb17-3"><a href="#cb17-3" tabindex="-1"></a>  <span class="at">b =</span> <span class="fu">bm_index</span>(<span class="dv">2</span>)</span>
<span id="cb17-4"><a href="#cb17-4" tabindex="-1"></a>))</span>
<span id="cb17-5"><a href="#cb17-5" tabindex="-1"></a><span class="fu">ibm_n</span>(mapper)</span>
<span id="cb17-6"><a href="#cb17-6" tabindex="-1"></a><span class="co">#&gt; [1] 6</span></span>
<span id="cb17-7"><a href="#cb17-7" tabindex="-1"></a><span class="fu">ibm_n</span>(mapper, <span class="at">multi =</span> <span class="cn">TRUE</span>)</span>
<span id="cb17-8"><a href="#cb17-8" tabindex="-1"></a><span class="co">#&gt; $a</span></span>
<span id="cb17-9"><a href="#cb17-9" tabindex="-1"></a><span class="co">#&gt; [1] 3</span></span>
<span id="cb17-10"><a href="#cb17-10" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb17-11"><a href="#cb17-11" tabindex="-1"></a><span class="co">#&gt; $b</span></span>
<span id="cb17-12"><a href="#cb17-12" tabindex="-1"></a><span class="co">#&gt; [1] 2</span></span>
<span id="cb17-13"><a href="#cb17-13" tabindex="-1"></a><span class="fu">ibm_values</span>(mapper)</span>
<span id="cb17-14"><a href="#cb17-14" tabindex="-1"></a><span class="co">#&gt; [1] 1 2 3 4 5 6</span></span>
<span id="cb17-15"><a href="#cb17-15" tabindex="-1"></a><span class="fu">ibm_values</span>(mapper, <span class="at">multi =</span> <span class="cn">TRUE</span>)</span>
<span id="cb17-16"><a href="#cb17-16" tabindex="-1"></a><span class="co">#&gt;   a b</span></span>
<span id="cb17-17"><a href="#cb17-17" tabindex="-1"></a><span class="co">#&gt; 1 1 1</span></span>
<span id="cb17-18"><a href="#cb17-18" tabindex="-1"></a><span class="co">#&gt; 2 2 1</span></span>
<span id="cb17-19"><a href="#cb17-19" tabindex="-1"></a><span class="co">#&gt; 3 3 1</span></span>
<span id="cb17-20"><a href="#cb17-20" tabindex="-1"></a><span class="co">#&gt; 4 1 2</span></span>
<span id="cb17-21"><a href="#cb17-21" tabindex="-1"></a><span class="co">#&gt; 5 2 2</span></span>
<span id="cb17-22"><a href="#cb17-22" tabindex="-1"></a><span class="co">#&gt; 6 3 2</span></span></code></pre></div>
<div class="sourceCode" id="cb18"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" tabindex="-1"></a><span class="fu">ibm_n</span>(mapper, <span class="at">inla_f =</span> <span class="cn">TRUE</span>)</span>
<span id="cb18-2"><a href="#cb18-2" tabindex="-1"></a><span class="co">#&gt; [1] 6</span></span>
<span id="cb18-3"><a href="#cb18-3" tabindex="-1"></a><span class="fu">ibm_n</span>(mapper, <span class="at">multi =</span> <span class="cn">TRUE</span>, <span class="at">inla_f =</span> <span class="cn">TRUE</span>)</span>
<span id="cb18-4"><a href="#cb18-4" tabindex="-1"></a><span class="co">#&gt; $a</span></span>
<span id="cb18-5"><a href="#cb18-5" tabindex="-1"></a><span class="co">#&gt; [1] 3</span></span>
<span id="cb18-6"><a href="#cb18-6" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb18-7"><a href="#cb18-7" tabindex="-1"></a><span class="co">#&gt; $b</span></span>
<span id="cb18-8"><a href="#cb18-8" tabindex="-1"></a><span class="co">#&gt; [1] 2</span></span>
<span id="cb18-9"><a href="#cb18-9" tabindex="-1"></a><span class="fu">ibm_values</span>(mapper, <span class="at">inla_f =</span> <span class="cn">TRUE</span>)</span>
<span id="cb18-10"><a href="#cb18-10" tabindex="-1"></a><span class="co">#&gt; [1] 1 2 3 4 5 6</span></span>
<span id="cb18-11"><a href="#cb18-11" tabindex="-1"></a><span class="fu">ibm_values</span>(mapper, <span class="at">multi =</span> <span class="cn">TRUE</span>, <span class="at">inla_f =</span> <span class="cn">TRUE</span>)</span>
<span id="cb18-12"><a href="#cb18-12" tabindex="-1"></a><span class="co">#&gt;   a b</span></span>
<span id="cb18-13"><a href="#cb18-13" tabindex="-1"></a><span class="co">#&gt; 1 1 1</span></span>
<span id="cb18-14"><a href="#cb18-14" tabindex="-1"></a><span class="co">#&gt; 2 2 1</span></span>
<span id="cb18-15"><a href="#cb18-15" tabindex="-1"></a><span class="co">#&gt; 3 3 1</span></span>
<span id="cb18-16"><a href="#cb18-16" tabindex="-1"></a><span class="co">#&gt; 4 1 2</span></span>
<span id="cb18-17"><a href="#cb18-17" tabindex="-1"></a><span class="co">#&gt; 5 2 2</span></span>
<span id="cb18-18"><a href="#cb18-18" tabindex="-1"></a><span class="co">#&gt; 6 3 2</span></span></code></pre></div>
<p>The default <code>ibm_inla_subset</code> method determines the inla
subset by comparing the full values information from
<code>ibm_values(mapper, inla_f = FALSE)</code> to the inla specific
values information from <code>ibm_values(mapper, inla_f = TRUE)</code>,
to determine the logical vector identifying the inla values subset.
Custom mappers should normally not need to specialise this method.</p>
</div>
<div id="mappers-for-inla.mesh-objects" class="section level2">
<h2>Mappers for inla.mesh objects</h2>
<p>For component models referenced by a character label
(e.g. <code>&quot;iid&quot;</code>, <code>&quot;bym2&quot;</code>, <code>&quot;rw2&quot;</code> etc),
inlabru will construct default mappers, that in most cases replicate the
default <code>INLA::f()</code> behaviour.</p>
<p>For the <code>fm_mesh_1d</code>, <code>fm_mesh_2d</code>,
<code>inla.mesh</code> and <code>inla.mesh.1d</code> classes, default
mappers can be constructed by the pre-defined <code>bru_mapper</code> S3
methods. For 2d meshes (<code>fm_mesh_2d</code>,
<code>inla.mesh</code>),</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" tabindex="-1"></a><span class="fu">bru_mapper</span>(mesh)</span></code></pre></div>
<p>For 1d meshes (<code>fm_mesh_1d</code>,
<code>inla.mesh.1d</code>),</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1" tabindex="-1"></a><span class="co"># If ibm_values() should return mesh$loc (e.g. for &quot;rw2&quot; models</span></span>
<span id="cb20-2"><a href="#cb20-2" tabindex="-1"></a><span class="co"># with degree=1 meshes)</span></span>
<span id="cb20-3"><a href="#cb20-3" tabindex="-1"></a><span class="fu">bru_mapper</span>(mesh, <span class="at">indexed =</span> <span class="cn">FALSE</span>)</span>
<span id="cb20-4"><a href="#cb20-4" tabindex="-1"></a><span class="co"># If ibm_values() should return seq_along(mesh$loc) (e.g. for</span></span>
<span id="cb20-5"><a href="#cb20-5" tabindex="-1"></a><span class="co"># inla.spde2.pcmatern() models)</span></span>
<span id="cb20-6"><a href="#cb20-6" tabindex="-1"></a><span class="fu">bru_mapper</span>(mesh, <span class="at">indexed =</span> <span class="cn">TRUE</span>)</span></code></pre></div>
</div>
<div id="customised-mappers" class="section level2">
<h2>Customised mappers</h2>
<p>A mapper object should store enough information in order for the
<code>ibm_*</code> methods to work. The simplest case of a customised
mapper is to just attached a new class label to the front of the S3
<code>class()</code> information of an existing mapper, to obtain a
class to override some of the standard <code>ibm_*</code> method
implementations. More commonly, one would instead start with a basic
<code>list()</code>, that might <em>contain</em> an existing mapper
object, and then add methods that know how to use that information. In
all these cases, the <code>bru_mapper_define()</code> method should be
used to properly set the class information:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1" tabindex="-1"></a><span class="fu">bru_mapper_define</span>(mapper, new_class)</span></code></pre></div>
<p>Implementations can avoid having to define <code>ibm_n</code> and
<code>ibm_values</code> methods, by instead computing and storing
<code>n</code>, <code>n_inla</code>, <code>values</code>, and
<code>values_inla</code> in the mapper object during construction:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1" tabindex="-1"></a><span class="fu">bru_mapper_define</span>(</span>
<span id="cb22-2"><a href="#cb22-2" tabindex="-1"></a>  <span class="at">mapper =</span> <span class="fu">list</span>(<span class="at">n =</span> <span class="dv">10</span>, <span class="at">values =</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">10</span>),</span>
<span id="cb22-3"><a href="#cb22-3" tabindex="-1"></a>  <span class="at">new_class =</span> <span class="st">&quot;my_bm_class_name&quot;</span></span>
<span id="cb22-4"><a href="#cb22-4" tabindex="-1"></a>)</span></code></pre></div>
<p>The default <code>ibm_n</code> and <code>ibm_values</code> methods
checks if these values are available, and return the appropriate values
depending on the <code>inla_f</code> argument. When <code>*_inla</code>
values are requested but not available, the methods fall back to the
non-inla versions. If the needed information is not found, the default
methods give an error message.</p>
<p>Note: Before version 2.6.0, <code>ibm_amatrix</code> was used instead
of <code>ibm_jacobian</code>. Version 2.6.0 still supports this, by
having the default <code>ibm_jacobian</code> method call
<code>ibm_amatrix</code>, but will give a deprecation message later, and
it may be removed in a future version.</p>
</div>
<div id="example" class="section level2">
<h2>Example</h2>
<p>Let’s build a mapper class <code>bm_p_quadratic</code> for a model
component that takes input covariates with values <span class="math inline">\(a_{ij}\)</span>, <span class="math inline">\(i=1,\dots,m\)</span> and <span class="math inline">\(j=1,\dots,p\)</span>, in a <code>matrix</code> or
<code>data.frame</code> and evaluates a full quadratic expression <span class="math display">\[
\eta_i = x_0 + \sum_{j=1}^p a_{ij} x_j +
  \frac{1}{2}\sum_{j=1}^p\sum_{k=1}^j \gamma_{j,k} a_{ij}a_{ik} x_{j,k},
\]</span> where the latent component vector is <span class="math inline">\(\boldsymbol{x}=[x_0,x_1,\dots,x_p,x_{1,1},\dots,x_{p,1},x_{2,2}\dots,x_{p,p}]\)</span>,
and <span class="math display">\[
\gamma_{j,k} = \begin{cases}
1, &amp; j = k,\\
2, &amp; j &gt; k.
\end{cases}
\]</span></p>
<p>We start with the constructor method. Like the
<code>bm_matrix</code>, we require the user to supply a vector of
covariate labels, and store them as a character vector. We also include
a <code>min_degree</code> parameter to control if an intercept
(<code>min_degree &lt;= 0</code>) and linear terms
(<code>min_degree &lt;= 1</code>) should be included in the model.</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1" tabindex="-1"></a>bm_p_quadratic <span class="ot">&lt;-</span> <span class="cf">function</span>(labels, <span class="at">min_degree =</span> <span class="dv">0</span>, ...) {</span>
<span id="cb23-2"><a href="#cb23-2" tabindex="-1"></a>  <span class="cf">if</span> (<span class="fu">is.factor</span>(labels)) {</span>
<span id="cb23-3"><a href="#cb23-3" tabindex="-1"></a>    mapper <span class="ot">&lt;-</span> <span class="fu">list</span>(</span>
<span id="cb23-4"><a href="#cb23-4" tabindex="-1"></a>      <span class="at">labels =</span> <span class="fu">levels</span>(labels),</span>
<span id="cb23-5"><a href="#cb23-5" tabindex="-1"></a>      <span class="at">min_degree =</span> min_degree</span>
<span id="cb23-6"><a href="#cb23-6" tabindex="-1"></a>    )</span>
<span id="cb23-7"><a href="#cb23-7" tabindex="-1"></a>  } <span class="cf">else</span> {</span>
<span id="cb23-8"><a href="#cb23-8" tabindex="-1"></a>    mapper <span class="ot">&lt;-</span> <span class="fu">list</span>(</span>
<span id="cb23-9"><a href="#cb23-9" tabindex="-1"></a>      <span class="at">labels =</span> <span class="fu">as.character</span>(labels),</span>
<span id="cb23-10"><a href="#cb23-10" tabindex="-1"></a>      <span class="at">min_degree =</span> min_degree</span>
<span id="cb23-11"><a href="#cb23-11" tabindex="-1"></a>    )</span>
<span id="cb23-12"><a href="#cb23-12" tabindex="-1"></a>  }</span>
<span id="cb23-13"><a href="#cb23-13" tabindex="-1"></a>  <span class="fu">bru_mapper_define</span>(mapper, <span class="at">new_class =</span> <span class="st">&quot;bm_p_quadratic&quot;</span>)</span>
<span id="cb23-14"><a href="#cb23-14" tabindex="-1"></a>}</span></code></pre></div>
<p>The <code>ibm_n</code> method can compute the value of <span class="math inline">\(n\)</span> from <span class="math inline">\(n=1+p+\frac{p(p+1)}{2}\)</span>:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb24-1"><a href="#cb24-1" tabindex="-1"></a>ibm_n.bm_p_quadratic <span class="ot">&lt;-</span> <span class="cf">function</span>(mapper, ...) {</span>
<span id="cb24-2"><a href="#cb24-2" tabindex="-1"></a>  p <span class="ot">&lt;-</span> <span class="fu">length</span>(mapper<span class="sc">$</span>labels)</span>
<span id="cb24-3"><a href="#cb24-3" tabindex="-1"></a>  (mapper<span class="sc">$</span>min_degree <span class="sc">&lt;=</span> <span class="dv">0</span>) <span class="sc">+</span> (mapper<span class="sc">$</span>min_degree <span class="sc">&lt;=</span> <span class="dv">1</span>) <span class="sc">*</span> p <span class="sc">+</span> p <span class="sc">*</span> (p <span class="sc">+</span> <span class="dv">1</span>) <span class="sc">/</span> <span class="dv">2</span></span>
<span id="cb24-4"><a href="#cb24-4" tabindex="-1"></a>}</span></code></pre></div>
<p>For <code>ibm_values</code>, the default method is sufficient,
returning the vector <span class="math inline">\([1,\dots,n]\)</span>
with <span class="math inline">\(n\)</span> obtained by
<code>ibm_n(mapper)</code>. However, for clearer result naming, we can
use a character vector, at least for INLA <code>f()</code> models that
allow it (we could have an option argument to the
<code>bm_p_quadratic</code> constructor to control this):</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb25-1"><a href="#cb25-1" tabindex="-1"></a>ibm_values.bm_p_quadratic <span class="ot">&lt;-</span> <span class="cf">function</span>(mapper, ...) {</span>
<span id="cb25-2"><a href="#cb25-2" tabindex="-1"></a>  p <span class="ot">&lt;-</span> <span class="fu">length</span>(mapper<span class="sc">$</span>labels)</span>
<span id="cb25-3"><a href="#cb25-3" tabindex="-1"></a>  n <span class="ot">&lt;-</span> <span class="fu">ibm_n</span>(mapper)</span>
<span id="cb25-4"><a href="#cb25-4" tabindex="-1"></a>  jk <span class="ot">&lt;-</span> <span class="fu">expand.grid</span>(<span class="fu">seq_len</span>(p), <span class="fu">seq_len</span>(p))</span>
<span id="cb25-5"><a href="#cb25-5" tabindex="-1"></a>  jk <span class="ot">&lt;-</span> jk[jk[, <span class="dv">2</span>] <span class="sc">&lt;=</span> jk[, <span class="dv">1</span>], , drop <span class="ot">=</span> <span class="cn">FALSE</span>]</span>
<span id="cb25-6"><a href="#cb25-6" tabindex="-1"></a>  <span class="fu">c</span>(</span>
<span id="cb25-7"><a href="#cb25-7" tabindex="-1"></a>    <span class="cf">if</span> (mapper<span class="sc">$</span>min_degree <span class="sc">&lt;=</span> <span class="dv">0</span>) <span class="st">&quot;Intercept&quot;</span> <span class="cf">else</span> <span class="cn">NULL</span>,</span>
<span id="cb25-8"><a href="#cb25-8" tabindex="-1"></a>    <span class="cf">if</span> (mapper<span class="sc">$</span>min_degree <span class="sc">&lt;=</span> <span class="dv">1</span>) mapper<span class="sc">$</span>labels <span class="cf">else</span> <span class="cn">NULL</span>,</span>
<span id="cb25-9"><a href="#cb25-9" tabindex="-1"></a>    <span class="fu">paste0</span>(mapper<span class="sc">$</span>labels[jk[, <span class="dv">1</span>]], <span class="st">&quot;:&quot;</span>, mapper<span class="sc">$</span>labels[jk[, <span class="dv">2</span>]])</span>
<span id="cb25-10"><a href="#cb25-10" tabindex="-1"></a>  )</span>
<span id="cb25-11"><a href="#cb25-11" tabindex="-1"></a>}</span></code></pre></div>
<p>While the approach to <code>ibm_n</code> and <code>ibm_values</code>
above works, it is wasteful to recompute the <code>n</code> and
<code>values</code> information for each call. Instead we can use that
the default method will check if <code>n</code> or <code>values</code>
are stored in the mapper object, and then return them. If we change the
<code>.</code> in the method definitions to <code>_</code>, we can end
the constructor method like this, making subsequent method calls
faster:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb26-1"><a href="#cb26-1" tabindex="-1"></a>bm_p_quadratic <span class="ot">&lt;-</span> <span class="cf">function</span>(labels, <span class="at">min_degree =</span> <span class="dv">0</span>, ...) {</span>
<span id="cb26-2"><a href="#cb26-2" tabindex="-1"></a>  ...</span>
<span id="cb26-3"><a href="#cb26-3" tabindex="-1"></a>  mapper <span class="ot">&lt;-</span> <span class="fu">bru_mapper_define</span>(mapper, <span class="at">new_class =</span> <span class="st">&quot;bm_p_quadratic&quot;</span>)</span>
<span id="cb26-4"><a href="#cb26-4" tabindex="-1"></a>  mapper<span class="sc">$</span>n <span class="ot">&lt;-</span> <span class="fu">ibm_n_bm_p_quadratic</span>(mapper)</span>
<span id="cb26-5"><a href="#cb26-5" tabindex="-1"></a>  mapper<span class="sc">$</span>values <span class="ot">&lt;-</span> <span class="fu">ibm_values_bm_p_quadratic</span>(mapper)</span>
<span id="cb26-6"><a href="#cb26-6" tabindex="-1"></a>  mapper</span>
<span id="cb26-7"><a href="#cb26-7" tabindex="-1"></a>}</span></code></pre></div>
<p>Note that the order matters, since our
<code>ibm_values_bm_p_quadratic</code> function calls
<code>ibm_n(mapper)</code>.</p>
<p>We can now define the main part of the mapper interface that computes
the model matrix linking the latent variables to the component effect.
It’s required that <code>NULL</code> input should return a <span class="math inline">\(0\)</span>-by-<span class="math inline">\(n\)</span> matrix.</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb27-1"><a href="#cb27-1" tabindex="-1"></a>ibm_jacobian.bm_p_quadratic <span class="ot">&lt;-</span> <span class="cf">function</span>(mapper, input, ...) {</span>
<span id="cb27-2"><a href="#cb27-2" tabindex="-1"></a>  <span class="cf">if</span> (<span class="fu">is.null</span>(input)) {</span>
<span id="cb27-3"><a href="#cb27-3" tabindex="-1"></a>    <span class="fu">return</span>(Matrix<span class="sc">::</span><span class="fu">Matrix</span>(<span class="dv">0</span>, <span class="dv">0</span>, <span class="fu">ibm_n</span>(mapper)))</span>
<span id="cb27-4"><a href="#cb27-4" tabindex="-1"></a>  }</span>
<span id="cb27-5"><a href="#cb27-5" tabindex="-1"></a>  p <span class="ot">&lt;-</span> <span class="fu">length</span>(mapper<span class="sc">$</span>labels)</span>
<span id="cb27-6"><a href="#cb27-6" tabindex="-1"></a>  n <span class="ot">&lt;-</span> <span class="fu">ibm_n</span>(mapper)</span>
<span id="cb27-7"><a href="#cb27-7" tabindex="-1"></a>  N <span class="ot">&lt;-</span> <span class="fu">NROW</span>(input)</span>
<span id="cb27-8"><a href="#cb27-8" tabindex="-1"></a>  A <span class="ot">&lt;-</span> <span class="fu">list</span>()</span>
<span id="cb27-9"><a href="#cb27-9" tabindex="-1"></a>  in_ <span class="ot">&lt;-</span> <span class="fu">as</span>(input, <span class="st">&quot;Matrix&quot;</span>)</span>
<span id="cb27-10"><a href="#cb27-10" tabindex="-1"></a>  idx <span class="ot">&lt;-</span> <span class="dv">0</span></span>
<span id="cb27-11"><a href="#cb27-11" tabindex="-1"></a>  <span class="cf">if</span> (mapper<span class="sc">$</span>min_degree <span class="sc">&lt;=</span> <span class="dv">0</span>) {</span>
<span id="cb27-12"><a href="#cb27-12" tabindex="-1"></a>    idx <span class="ot">&lt;-</span> idx <span class="sc">+</span> <span class="dv">1</span></span>
<span id="cb27-13"><a href="#cb27-13" tabindex="-1"></a>    A[[idx]] <span class="ot">&lt;-</span> Matrix<span class="sc">::</span><span class="fu">Matrix</span>(<span class="dv">1</span>, N)</span>
<span id="cb27-14"><a href="#cb27-14" tabindex="-1"></a>  }</span>
<span id="cb27-15"><a href="#cb27-15" tabindex="-1"></a>  <span class="cf">if</span> (mapper<span class="sc">$</span>min_degree <span class="sc">&lt;=</span> <span class="dv">1</span>) {</span>
<span id="cb27-16"><a href="#cb27-16" tabindex="-1"></a>    idx <span class="ot">&lt;-</span> idx <span class="sc">+</span> <span class="dv">1</span></span>
<span id="cb27-17"><a href="#cb27-17" tabindex="-1"></a>    A[[idx]] <span class="ot">&lt;-</span> in_</span>
<span id="cb27-18"><a href="#cb27-18" tabindex="-1"></a>  }</span>
<span id="cb27-19"><a href="#cb27-19" tabindex="-1"></a>  <span class="cf">for</span> (k <span class="cf">in</span> <span class="fu">seq_len</span>(p)) {</span>
<span id="cb27-20"><a href="#cb27-20" tabindex="-1"></a>    idx <span class="ot">&lt;-</span> idx <span class="sc">+</span> <span class="dv">1</span></span>
<span id="cb27-21"><a href="#cb27-21" tabindex="-1"></a>    A[[idx]] <span class="ot">&lt;-</span> in_[, <span class="fu">seq</span>(k, p, <span class="at">by =</span> <span class="dv">1</span>), drop <span class="ot">=</span> <span class="cn">FALSE</span>] <span class="sc">*</span> in_[, k]</span>
<span id="cb27-22"><a href="#cb27-22" tabindex="-1"></a>    A[[idx]][, k] <span class="ot">&lt;-</span> A[[idx]][, k] <span class="sc">/</span> <span class="dv">2</span></span>
<span id="cb27-23"><a href="#cb27-23" tabindex="-1"></a>  }</span>
<span id="cb27-24"><a href="#cb27-24" tabindex="-1"></a>  A <span class="ot">&lt;-</span> <span class="fu">do.call</span>(cbind, A)</span>
<span id="cb27-25"><a href="#cb27-25" tabindex="-1"></a>  <span class="fu">colnames</span>(A) <span class="ot">&lt;-</span> <span class="fu">as.character</span>(<span class="fu">ibm_values</span>(mapper))</span>
<span id="cb27-26"><a href="#cb27-26" tabindex="-1"></a>  A</span>
<span id="cb27-27"><a href="#cb27-27" tabindex="-1"></a>}</span></code></pre></div>
<p>If the output of a mapper is of a different size than
<code>NROW(input)</code>, the mapper should define a
<code>ibm_n_output(mapper, input, ...)</code> method to return the
output size for a given input.</p>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
